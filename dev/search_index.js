var documenterSearchIndex = {"docs":
[{"location":"handlemissings.html#Default-Handling-of-missing-values","page":"Default","title":"Default Handling of missing values","text":"","category":"section"},{"location":"handlemissings.html","page":"Default","title":"Default","text":"The macro @handlemissing allows to easily define methods for functions that were constructed with non-missing interface. These methods implement default handling for PassMissing and HanldeMissingStragegy.","category":"page"},{"location":"handlemissings.html","page":"Default","title":"Default","text":"@handlemissings","category":"page"},{"location":"handlemissings.html#MissingStrategies.@handlemissings","page":"Default","title":"MissingStrategies.@handlemissings","text":"@handlemissings(fun, collectskipped=false, definedefault=false)\n\nDefine several methods for function fun  that handle missing values in the elements of its first argument.\n\nThe new methods dispatch on their first argument of trait IsEltypeSuperOfMissing.  The second argument is of type MissingStrategy.\n\n@traitfun fun(x1::::IsEltypeSuperOfMissing, ::PassMissing, ...)  returns missing if there is any missing element in x.  Otherwise, it converts the type of each element to the corresponding nonmissing type and calls the original function\n@traitfun fun(x1::::IsEltypeSuperOfMissing, ::HandleMissingStrategy, ...)  passes the first argument to Missings.skipmissing and optionally to Base.collect, before calling the original function.\n@traitfun fun(x1::::!(IsEltypeSuperOfMissing), ::MissingStrategy, ...)  calls the original function with unchanged x1. This allows passing both argument types, including and not including missings, to the method with a MissingStrategy argument.\n\nDefault method without strategy?\n\nBy setting argument definedefault=true an additional method is defined:\n\n@traitfun fun(x1::::IsEltypeSuperOfMissing, ...) forwarding to the fun(x1, PassMissing(), ...) as a default for handling missings.\n\nHowever, if the original method has no specific type attached, then this new method is never called, but rather the original method is called. Furthermore, this can create methods which may accidentally match non-missing arguments  for which the original funciton threw an MethodError and may cause indefine  loop and StackOverFlow. Hence, its recommended to only define the default method, if the original method explicitly constrains its type to non-missing.\n\nNotes\n\nFor extending or overwriting the defintitions created by @handlemissings the IsEltypeSuperOfMissing trait is useful. \n\nNote, that supplying a generator to the first argument,  does not work with @handlemissing, because eltype(<generator>) == Any.  Use typediter to explicitly associate an eltype, which may be a supertype of Missing.\n\nExamples\n\n# a function desinged with not caring for missings in xvec:\nfrealvec(xvec::AbstractVector{<:Real}) = xvec\n\n@handlemissings(frealvec, true, true) # defines several new methods\n\n# define specific subtype of HandleMissingStrategy explicitly \nusing SimpleTraits\n@traitfn function frealvec(x1::::IsEltypeSuperOfMissing, \n  ::ExactMissing, x...; kwargs...) \n  \"return exact computation here\"\nend\n\nfrealvec([1,2]) # calls original method\nxm = [1,2,missing]      # caused a MethodError on original frealvec\nfrealvec(xm, PassMissing()) === missing\nfrealvec(xm, SkipMissing()) == frealvec([1,2]) \nfrealvec(xm) === missing     # default method forwarding to PassMissing() \n#frealvec(1)       # beware: formerly \"MethodError\" now results in an indefinite loop\nfrealvec(xm, ExactMissing()) == \"return exact computation here\"\n\n\n\n\n\n","category":"macro"},{"location":"missingstrategy.html#Strategies-for-dealing-with-missings","page":"Types","title":"Strategies for dealing with missings","text":"","category":"section"},{"location":"missingstrategy.html","page":"Types","title":"Types","text":"The following types support methods to deal with presence of missing values in their inputs.","category":"page"},{"location":"missingstrategy.html","page":"Types","title":"Types","text":"MissingStrategy","category":"page"},{"location":"missingstrategy.html#MissingStrategies.MissingStrategy","page":"Types","title":"MissingStrategies.MissingStrategy","text":"MissingStrategy()\n\nSuptertype of Abstract and Singleton Types that signify how a method should deal with missing values\n\n└PassMissing: Singleton: return missing, if a missing value is encountered\n└HandleMissingStrategy: Abstract type: take missing values consciously into account\n└SkipMissing: ignore missing values\n└ExactMissing: unbiased processing \n\nSee @handlemissings on how to extend functions by methods handling these strategies.  \n\n\n\n\n\n","category":"type"},{"location":"missingstrategy.html","page":"Types","title":"Types","text":"Usually, methods should return missing if there are missings present in the input. This PassMissing() strategy ensures,  that missing are not accidently bypassed unconsciously.  Hence, PassMissing() is a good default value for the strategy.","category":"page"},{"location":"missingstrategy.html","page":"Types","title":"Types","text":"If a caller knows that there might by missing values present, he can consciously request to handle missings by supplying one of subtypes of HandleMissingStrategy. For an explicit dealing with missings that may cause some cost in computation use ExactMissing. For ignoring missing values use SkipMissing.","category":"page"},{"location":"missingstrategy.html#Design-choices","page":"Types","title":"Design choices","text":"","category":"section"},{"location":"missingstrategy.html","page":"Types","title":"Types","text":"The design strategies alternatively could be passed by keyword arguments, e.g. skipmissing::Bool=true or by an enum type. Modelling the strategies by a type system allows the dispatch system and the  compiler to work on them. ","category":"page"},{"location":"missingstrategy.html","page":"Types","title":"Types","text":"This comes with several advantages:","category":"page"},{"location":"missingstrategy.html","page":"Types","title":"Types","text":"Avoid method matching ambiguities across existing methods that cannot handle missing values and their extensions by the same name and argument types aside from the MissingStrategy.\nGenerate efficient code, because if branches can be pruned at compile time\nExtensible to further strategies","category":"page"},{"location":"iseltypesuperofmissing.html#Dispatching-on-Collection-of-missings","page":"Dispatch","title":"Dispatching on Collection of missings","text":"","category":"section"},{"location":"iseltypesuperofmissing.html","page":"Dispatch","title":"Dispatch","text":"Trait IsEltypeSuperOfMissing defined using SimpleTraits.jl allows dispatching on any collection of eltype containing missings.","category":"page"},{"location":"iseltypesuperofmissing.html","page":"Dispatch","title":"Dispatch","text":"IsEltypeSuperOfMissing","category":"page"},{"location":"iseltypesuperofmissing.html#MissingStrategies.IsEltypeSuperOfMissing","page":"Dispatch","title":"MissingStrategies.IsEltypeSuperOfMissing","text":"Trait which contains all types with Missing in its element type (eltype),  excluding Any.\n\nThis allows dispatching on any Collection (Iterator, Vector, Tuple) that may contain missing elements.\n\nSee example of @handlemissings for an application.\n\n\n\n\n\n","category":"type"},{"location":"index.html#MissingStrategies.jl","page":"Home","title":"MissingStrategies.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":" MissingStrategies","category":"page"},{"location":"index.html#MissingStrategies","page":"Home","title":"MissingStrategies","text":"Support handling of missing values by\n\na typed hierarchy of strategies of dealing with missings\na trait that helps dispatching on eltype that allows missing\na macro allowing to easily extend functions by methods that deal with missings\n\n\n\n\n\n","category":"module"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\"missingstrategy.md\", \"iseltypesuperofmissing.md\", \"handlemissings.md\", \n\"typediter.md\"]\nDepth = 2","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"See all the github repository.","category":"page"},{"location":"typediter.html#Iterator-with-known-eltype","page":"TypedIteraotr","title":"Iterator with known eltype","text":"","category":"section"},{"location":"typediter.html","page":"TypedIteraotr","title":"TypedIteraotr","text":"typediter","category":"page"},{"location":"typediter.html#MissingStrategies.typediter","page":"TypedIteraotr","title":"MissingStrategies.typediter","text":"typediter(::Type{ET},iter::IT)\nTypedIterator{IT,ET}\n\nConstruct a thin wrapper around iterator IT returning eltype ET.\n\nExamples\n\nusing SimpleTraits\nx = [1,2,missing]\n@traitfn fm(x::::IsEltypeSuperOfMissing)  = count(ismissing.(x))\n\ngen = (2*xi for xi in x)  \neltype(gen) == Any\n#fm(gen)  # MethodError\n\ngent = typediter(eltype(x), 2*xi for xi in x)\neltype(gent) == eltype(x)\nfm(gent) == 1\n\n\n\n\n\n","category":"function"}]
}
