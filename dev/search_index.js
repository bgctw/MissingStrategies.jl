var documenterSearchIndex = {"docs":
[{"location":"handlemissings.html#Default-Handling-of-missing-values","page":"Default","title":"Default Handling of missing values","text":"","category":"section"},{"location":"handlemissings.html","page":"Default","title":"Default","text":"Several functions and macros help to extend functions  that were designed not taking care of missing values. ","category":"page"},{"location":"handlemissings.html#Main-macros","page":"Default","title":"Main macros","text":"","category":"section"},{"location":"handlemissings.html","page":"Default","title":"Default","text":"The main tools are macros ","category":"page"},{"location":"handlemissings.html","page":"Default","title":"Default","text":"@handlemissings_stub: defines only the dispatch infrastructure to be  extended manually\n@handlemissings_typed: additionally defines default handling for  PassMissing and SkipMissing for arguments whose eltye does not match missings\n@handlemissings_any: define these handling  for arguments whose eltype does match missings including Any.","category":"page"},{"location":"handlemissings.html","page":"Default","title":"Default","text":"@handlemissings_stub\n@handlemissings_typed\n@handlemissings_any","category":"page"},{"location":"handlemissings.html#MissingStrategies.@handlemissings_stub","page":"Default","title":"MissingStrategies.@handlemissings_stub","text":"@handlemissings_stub(fun, ...)\n\nCalling handlemissings with just creating the disaptching matches but no implementations yet that handling missings.\n\nDefault to using argument type Any and providing no default strategy  (use arguments to change this.)\nMethod with inserted MissingStrategy argument that forwards to the dispatching function\nA dispaching method for eltypes not allowing for missings for any MissingStrategy that calls the original function without the MissingStrategy.\n\nArguments: see handlemissings    \n\nOne then can define the other methods yourself using Simpletraits @traitfn.\n\nusing SimpleTraits\nf1(x::AbstractArray{<:Real}) = \"method that is not accepting missings in eltype\"\n@handlemissings_stub(\n  # signature matching that of the original function to be called\n  f1(x::AbstractArray{<:Real}) = 0,\n  # pos_missing, pos_strategy, type_missing, defaultstrategy\n  1,2,AbstractArray{<:Union{Missing,Real}}, PassMissing()\n) \nmethods(f1) # just to see that new methods have been defined\n# the new methods forward to new function f1_hm that can be extended for special cases\n# note the argument order: missing strategy comes first in the dispatching function\n@traitfn function f1_hm(ms::PassMissing, x::::IsEltypeSuperOfMissing) \n  \"method handling missings in eltype\"\nend\nf1([1.0,2.0]) == \"method that is not accepting missings in eltype\"\nf1([1.0,2.0], PassMissing()) == \"method that is not accepting missings in eltype\"\nf1([1.0,2.0,missing]) == \"method handling missings in eltype\"\n\n\n\n\n\n","category":"macro"},{"location":"handlemissings.html#MissingStrategies.@handlemissings_typed","page":"Default","title":"MissingStrategies.@handlemissings_typed","text":"@handlemissings_typed(fun, ...)\n\nCalling handlemissings with defaults tailored to an original method where the  eltype does not accepts missings:\n\nDispatching methods as with @handlemissings_stub\nArgument type of the new function must be specified. May use Any. A default method (without MissingStrategy argument) is created that forwards to the  PassMissing method. Hence, Make sure that the argument type differs from the original method so that the original method its not overwritten.\nPassMissing method calls the original method with an broadcast where each element has been converted to the corresponding nonmissing type (mgen.passmissing_convert).\nSkipMissing method collects the skipmissing object before calling the original function (mgen.handlemissing_collect_skip).\n\nArguments: see handlemissings    \n\nNote on default MissingStrategy\n\nNote, that defining a default Missingstrategy at an argument position before further  optional arguments behaves in a way that may not be intuitive.\n\nf2(x::AbstractArray{<:Real},optarg=1:3) = x\n@handlemissings_typed(f2(x::AbstractArray{<:Real},optarg=1:3)=0,1,2,Any)\n# f2(x,ms::MissingStrategy=PassMissing(),optarg=1:3) # generated\n# f2([1.0,missing], 2:4) # no method defined -> rethink argument ordering\n\nIn order to call the PassMissing variant in the above case, one would need to  call @handle_missing_typed separately for the method with a single and the method with two arguments  and place the default missing strategy behind the second argument in the second case.\n\nf3(x::AbstractArray{<:Real},optarg=1:3) = x\n@handlemissings_typed(f3(x::AbstractArray{<:Real})=0,1,2,Any)\n@handlemissings_typed(f3(x::AbstractArray{<:Real}, optarg)=0,1,3,Any)\nismissing(f3([1.0,missing], 2:4))\n\n\n\n\n\n","category":"macro"},{"location":"handlemissings.html#MissingStrategies.@handlemissings_any","page":"Default","title":"MissingStrategies.@handlemissings_any","text":"@handlemissings_any(fun, ...)\n\nCalling handlemissings with defaults tailored to an original method where the  eltype accepts missings already:\n\nDispatching methods as with @handlemissings_stub\nAgument type of the new function defaults to Any. No default method (without the MissingStragety argument) is created.\nPassMissing methods calls the original directly without converting the type of the  argument with missings (mgen.passmissing_nonconvert).\nHandleMissing methods calls the original directly with the skipmissing()  iterator object (mgen.handlemissing_skip).\n\nArguments: see handlemissings    \n\nNote, that if the original method allows missing in eltype, you need to explicitly pass the PassMissing() by argument. A potential default method would override the original method and either not be called at all or call itself recursively causing an infinite loop.\n\n\n\n\n\n","category":"macro"},{"location":"handlemissings.html#Infrastructure","page":"Default","title":"Infrastructure","text":"","category":"section"},{"location":"handlemissings.html","page":"Default","title":"Default","text":"The macros above just wrap a call to the handlemissings function using  different argument values, especially different generator functions.","category":"page"},{"location":"handlemissings.html","page":"Default","title":"Default","text":"handlemissings","category":"page"},{"location":"handlemissings.html#MissingStrategies.handlemissings","page":"Default","title":"MissingStrategies.handlemissings","text":"handlemissings(fun, ...)\n\nCreates an expression that defines new methods that allow missings in the  eltype of an argument.\n\nArguments\n\nfun: Expression of a function to extend\npos_missing = 1: The postition of the argument that should handle missings\npos_strategy = pos_missing + 1: The position at which the argument of MissingStrategy  is to be inserted into the function signature\ntype_missing = :Any: The new type of the argument that should handle missings.  This can be an expression of the value.\ndefaultstrategy::Union{Nothing,MissingStrategy} = :nothing: the value of the default  of the strategy argument. Use :nothing to indicate not specifying a default value. This can be an expression of the value.\ngens = (): Tuple of generator functions (see [mgen]{@ref})\nargname_strategy = :ms: symbol of the argument name of the strategy argument\nsuffix=\"_hm\": attached to the name of the dispatching function to avoid method ambiguities\n\nUsusually this function is called from a macro that povide suitable dfault values\n\n@handlemissings_typed suitable if the type of the original method does not allow missing value\n@handlemissings_any suitable if the type of the original method does allow missing value. \n@handlemissings_stub suitable for writing user-specified handling routines. \n\n\n\n\n\n","category":"function"},{"location":"handlemissings.html","page":"Default","title":"Default","text":"The SimpleTraits package together with the IsEltypeSuperOfMissing trait  is used to dispatch to different methods depending on whether the eltype of a given argument allows for missing or does not allow for missings.","category":"page"},{"location":"handlemissings.html","page":"Default","title":"Default","text":"The orginal method is extended by a method signature with modified the type of a given argument, usually to eltype Union{Missing,<eltype_orig>} and an additional argument ms::MissingStrategy. The new method forwards to a dispatching function of name <name_orig>_<suffix> with MissingStrategy as the first argument and  given argument x of type x::::IsEltypeSuperOfMissing. The suffix defaults to \"_hm\"  but an be changed to avoid method ambiguities if methods are extended that differ only by the original type of x. A further advantage of using a separate dispatching method is, that  the original function is not extended by too many new methods.","category":"page"},{"location":"handlemissings.html","page":"Default","title":"Default","text":"The dispatching function can be extended by SimpleTraits.@traitfn to handle the differnt combinations of whether eltye of x was missing or not and the different Missing strategies. See @handlemissings_stub for an example.","category":"page"},{"location":"handlemissings.html#Generator-functions","page":"Default","title":"Generator functions","text":"","category":"section"},{"location":"handlemissings.html","page":"Default","title":"Default","text":"The argument gens of handlemissings takes a tuple of generator functions,  that do the actual work of defining additional methods.","category":"page"},{"location":"handlemissings.html","page":"Default","title":"Default","text":"The used generator functions are defined in submodule mgen","category":"page"},{"location":"handlemissings.html","page":"Default","title":"Default","text":"mgen\nmgen.forwarder()\nmgen.missingstrategy_notsuperofeltype()\nmgen.passmissing_nonconvert()\nmgen.passmissing_convert()\nmgen.handlemissing_collect_skip()\nmgen.handlemissing_skip()","category":"page"},{"location":"handlemissings.html#MissingStrategies.mgen","page":"Default","title":"MissingStrategies.mgen","text":"Submodule defining functions that generate specific methods that handle missings. They are called from within handlemissings.\n\nThe keyword arguments of the generator functions correspond to entries in  getdispatchinfo.\n\n\n\n\n\n","category":"module"},{"location":"handlemissings.html#MissingStrategies.mgen.forwarder-Tuple{}","page":"Default","title":"MissingStrategies.mgen.forwarder","text":"forwarder(...)\n\nDefines a method with new type of missing argument and MissingStrategy inserted forwarding to dispatching function of new name with MissingStrategy at first position.\n\n\n\n\n\n","category":"method"},{"location":"handlemissings.html#MissingStrategies.mgen.missingstrategy_notsuperofeltype-Tuple{}","page":"Default","title":"MissingStrategies.mgen.missingstrategy_notsuperofeltype","text":"missingstrategy_notsuperofeltype(...)\n\nDefines a trait method for any MissingStrategy for arguments whose eltype does not allow   missing. This just forwards to the original function.\n\n\n\n\n\n","category":"method"},{"location":"handlemissings.html#MissingStrategies.mgen.passmissing_nonconvert-Tuple{}","page":"Default","title":"MissingStrategies.mgen.passmissing_nonconvert","text":"passmissing_nonconvert(...)\n\nDefines a trait method for PassMissing for arguments whose eltype allowing missing. This method returns missing if any missing items are encoured or otherwise calls the original function with non-modified arguments, i.e. with type that  allows missings in its eltype.\n\n\n\n\n\n","category":"method"},{"location":"handlemissings.html#MissingStrategies.mgen.passmissing_convert-Tuple{}","page":"Default","title":"MissingStrategies.mgen.passmissing_convert","text":"passmissing_convert(...)\n\nDefines a trait method for PassMissing for arguments whose eltype allowing missing. This method returns missing if any missing items are encoured or otherwise calls the original function, but converts the argument to the corresponding nonmissing type.\n\n\n\n\n\n","category":"method"},{"location":"handlemissings.html#MissingStrategies.mgen.handlemissing_collect_skip-Tuple{}","page":"Default","title":"MissingStrategies.mgen.handlemissing_collect_skip","text":"handlemissing_collect_skip(...)\n\nDefines a trait method for HandleMissingStrategy  for arguments whose eltype allows missings. This method transforms the argument by collect(skipmissing(x)) before passing it on to the original function.\n\nHence it passes a vector with corresponding nonmissing eltype, but does require allocation.  \n\n\n\n\n\n","category":"method"},{"location":"handlemissings.html#MissingStrategies.mgen.handlemissing_skip-Tuple{}","page":"Default","title":"MissingStrategies.mgen.handlemissing_skip","text":"handlemissing_skip(...)\n\nDefines a trait method for HandleMissingStrategy  for arguments whose eltype allows missings. This method transforms the argument by skipmissing(x) before passing it on to the original function.\n\nHence it passes an itereator of undefined type but does not require allocations.  \n\n\n\n\n\n","category":"method"},{"location":"handlemissings.html","page":"Default","title":"Default","text":"Each generator function requires arguments that are collected by and passed by splatting the dictionary results in the call of a generator function.","category":"page"},{"location":"handlemissings.html","page":"Default","title":"Default","text":"getdispatchinfo","category":"page"},{"location":"handlemissings.html#MissingStrategies.getdispatchinfo","page":"Default","title":"MissingStrategies.getdispatchinfo","text":"getdispatchinfo(...)\n\nCollect information for dispatching non-missing types into a dictionary.\n\nArguments\n\nsee handlemissings.\n\nReturn value\n\nA dictionary with entries   \n\ndict_forig: dictionary result of MacroTools.splitdef(fun)\nfname_disp: Symbol of the dispatch function name, \nargnames: the aguement names of fun, \nkwargpasses: an Vector of expression of keyword parameters 'argname = argname'\npos_missing: position of the argument that should handle missings, \ntype_missing: the new type of that argument,\npos_strategy: the position at which the argument of MissingStrategy is inserted, \ndefaultstrategy: the default of that argument of type MissingStrategy\nsuffix=\"_hm\": number to be appended to fname_disp to avoid method ambiguities,\n\nThese match the required argument for the method generators in module mgen.\n\n\n\n\n\n","category":"function"},{"location":"missingstrategy.html#Strategies-for-dealing-with-missings","page":"Types","title":"Strategies for dealing with missings","text":"","category":"section"},{"location":"missingstrategy.html","page":"Types","title":"Types","text":"The following types support methods to deal with presence of missing values in their inputs.","category":"page"},{"location":"missingstrategy.html","page":"Types","title":"Types","text":"MissingStrategy","category":"page"},{"location":"missingstrategy.html#MissingStrategies.MissingStrategy","page":"Types","title":"MissingStrategies.MissingStrategy","text":"MissingStrategy()\n\nSuptertype of Abstract and Singleton Types that signify how a method should deal with missing values\n\n└PassMissing: Singleton: return missing, if a missing value is encountered\n└HandleMissingStrategy: Abstract type: take missing values consciously into account\n└SkipMissing: ignore missing values\n└ExactMissing: unbiased processing \n\nSee @handlemissings_typed on how to extend functions by methods handling these strategies.  \n\n\n\n\n\n","category":"type"},{"location":"missingstrategy.html","page":"Types","title":"Types","text":"Usually, methods should return missing if there are missings present in the input. This PassMissing() strategy ensures,  that missing are not accidently bypassed unconsciously.  Hence, PassMissing() is a good default value for the strategy.","category":"page"},{"location":"missingstrategy.html","page":"Types","title":"Types","text":"If a caller knows that there might by missing values present, he can consciously request to handle missings by supplying one of subtypes of HandleMissingStrategy. For an explicit dealing with missings that may cause some cost in computation use ExactMissing. For ignoring missing values use SkipMissing.","category":"page"},{"location":"missingstrategy.html#Design-choices","page":"Types","title":"Design choices","text":"","category":"section"},{"location":"missingstrategy.html","page":"Types","title":"Types","text":"The design strategies alternatively could be passed by keyword arguments, e.g. skipmissing::Bool=true or by an enum type. Modelling the strategies by a type system allows the dispatch system and the  compiler to work on them. ","category":"page"},{"location":"missingstrategy.html","page":"Types","title":"Types","text":"This comes with several advantages:","category":"page"},{"location":"missingstrategy.html","page":"Types","title":"Types","text":"Avoid method matching ambiguities across existing methods that cannot handle missing values and their extensions by the same name and argument types aside from the MissingStrategy.\nGenerate efficient code, because if branches can be pruned at compile time\nExtensible to further strategies","category":"page"},{"location":"iseltypesuperofmissing.html#Dispatching-on-Collection-of-missings","page":"Dispatch","title":"Dispatching on Collection of missings","text":"","category":"section"},{"location":"iseltypesuperofmissing.html","page":"Dispatch","title":"Dispatch","text":"Trait IsEltypeSuperOfMissing defined using SimpleTraits.jl allows dispatching on any collection of eltype containing missings.","category":"page"},{"location":"iseltypesuperofmissing.html","page":"Dispatch","title":"Dispatch","text":"IsEltypeSuperOfMissing","category":"page"},{"location":"iseltypesuperofmissing.html#MissingStrategies.IsEltypeSuperOfMissing","page":"Dispatch","title":"MissingStrategies.IsEltypeSuperOfMissing","text":"Trait which contains all types with Missing in its element type (eltype),  excluding Any.\n\nThis allows dispatching on any Collection (Iterator, Vector, Tuple) that may contain missing elements.\n\nSee example of @handlemissings_stub for an application.\n\n\n\n\n\n","category":"type"},{"location":"index.html#MissingStrategies.jl","page":"Home","title":"MissingStrategies.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":" MissingStrategies","category":"page"},{"location":"index.html#MissingStrategies","page":"Home","title":"MissingStrategies","text":"Support handling of missing values by\n\na typed hierarchy of strategies of dealing with missings\na trait that helps dispatching on eltype that allows missing\na macro allowing to easily extend functions by methods that deal with missings\n\n\n\n\n\n","category":"module"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\"missingstrategy.md\", \"iseltypesuperofmissing.md\", \"handlemissings.md\", \n\"typediter.md\"]\nDepth = 2","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"See all the github repository.","category":"page"},{"location":"typediter.html#Iterator-with-known-eltype","page":"TypedIterator","title":"Iterator with known eltype","text":"","category":"section"},{"location":"typediter.html","page":"TypedIterator","title":"TypedIterator","text":"typediter","category":"page"},{"location":"typediter.html#MissingStrategies.typediter","page":"TypedIterator","title":"MissingStrategies.typediter","text":"typediter(::Type{ET},iter::IT)\nTypedIterator{IT,ET}\n\nConstruct a thin wrapper around iterator IT returning eltype ET.\n\nExamples\n\nusing SimpleTraits\nx = [1,2,missing]\n@traitfn fm(x::::IsEltypeSuperOfMissing)  = count(ismissing.(x))\n\ngen = (2*xi for xi in x)  \neltype(gen) == Any\n#fm(gen)  # MethodError\n\ngent = typediter(eltype(x), 2*xi for xi in x)\neltype(gent) == eltype(x)\nfm(gent) == 1\n\n\n\n\n\n","category":"function"}]
}
